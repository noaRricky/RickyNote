(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{365:function(v,_,a){"use strict";a.r(_);var t=a(42),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"字节跳动提前批面试题目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字节跳动提前批面试题目"}},[v._v("#")]),v._v(" 字节跳动提前批面试题目")]),v._v(" "),a("h2",{attrs:{id:"java的三个特性：封装、继承、多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java的三个特性：封装、继承、多态"}},[v._v("#")]),v._v(" java的三个特性：封装、继承、多态")]),v._v(" "),a("h2",{attrs:{id:"封装的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装的优点"}},[v._v("#")]),v._v(" 封装的优点")]),v._v(" "),a("p",[v._v("在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n要访问该类的代码和数据，必须通过严格的接口控制。\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n封装的优点:")]),v._v(" "),a("ol",[a("li",[v._v("良好的封装能够减少耦合。")]),v._v(" "),a("li",[v._v("类内部的结构可以自由修改。")]),v._v(" "),a("li",[v._v("可以对成员变量进行更精确的控制。")]),v._v(" "),a("li",[v._v("隐藏信息，实现细节。")])]),v._v(" "),a("h2",{attrs:{id:"java多态怎么实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java多态怎么实现的"}},[v._v("#")]),v._v(" java多态怎么实现的")]),v._v(" "),a("ul",[a("li",[v._v("https://www.cnblogs.com/kaleidoscope/p/9790766.html")]),v._v(" "),a("li",[v._v("先通过栈帧中的对象引用找到对象")]),v._v(" "),a("li",[v._v("分析对象头，找到对象的实际Class")]),v._v(" "),a("li",[v._v("Class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了")]),v._v(" "),a("li",[v._v("查表得到方法的具体地址")]),v._v(" "),a("li",[v._v("执行方法的字节码")])]),v._v(" "),a("h2",{attrs:{id:"接口和抽象类有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类有什么区别"}},[v._v("#")]),v._v(" 接口和抽象类有什么区别")]),v._v(" "),a("p",[v._v("接口是对动作的抽象，抽象类是对根源的抽象。")]),v._v(" "),a("p",[v._v("1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。")]),v._v(" "),a("p",[v._v("2、抽象类要被子类继承，接口要被类实现。")]),v._v(" "),a("p",[v._v("3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现")]),v._v(" "),a("p",[v._v("4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。")]),v._v(" "),a("p",[v._v("5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。")]),v._v(" "),a("p",[v._v("6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果")]),v._v(" "),a("p",[v._v("7、抽象类里可以没有抽象方法")]),v._v(" "),a("p",[v._v("8、如果一个类里有抽象方法，那么这个类只能是抽象类")]),v._v(" "),a("p",[v._v("9、抽象方法要被实现，所以不能是静态的，也不能是私有的。")]),v._v(" "),a("p",[v._v("10、接口可继承接口，并可多继承接口，但类只能单根继承。")]),v._v(" "),a("h2",{attrs:{id:"hashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[v._v("#")]),v._v(" HashMap")]),v._v(" "),a("p",[v._v("https://zhuanlan.zhihu.com/p/129724004")]),v._v(" "),a("h2",{attrs:{id:"进程间通信有哪些，各个优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信有哪些，各个优缺点"}},[v._v("#")]),v._v(" 进程间通信有哪些，各个优缺点")]),v._v(" "),a("p",[v._v("进程间通信又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:\n1、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)\n2、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).")]),v._v(" "),a("p",[v._v("管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。\n信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n[共享内存( shared memory )] ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。")]),v._v(" "),a("h2",{attrs:{id:"负载均衡算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡算法"}},[v._v("#")]),v._v(" 负载均衡算法")]),v._v(" "),a("p",[v._v("1、轮询法")]),v._v(" "),a("p",[v._v("将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。")]),v._v(" "),a("p",[v._v("2、随机法")]),v._v(" "),a("p",[v._v("通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，")]),v._v(" "),a("p",[v._v("其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。")]),v._v(" "),a("p",[v._v("3、源地址哈希法")]),v._v(" "),a("p",[v._v("源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。")]),v._v(" "),a("p",[v._v("4、加权轮询法")]),v._v(" "),a("p",[v._v("不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。")]),v._v(" "),a("p",[v._v("5、加权随机法")]),v._v(" "),a("p",[v._v("与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。")]),v._v(" "),a("p",[v._v("6、最小连接数法")]),v._v(" "),a("p",[v._v("最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前")]),v._v(" "),a("p",[v._v("积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。")]),v._v(" "),a("h2",{attrs:{id:"select-poll-epoll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#select-poll-epoll"}},[v._v("#")]),v._v(" select/poll/epoll")]),v._v(" "),a("p",[v._v("https://www.cnblogs.com/Anker/p/3265058.html")]),v._v(" "),a("h2",{attrs:{id:"隔离级别和mysql的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别和mysql的实现"}},[v._v("#")]),v._v(" 隔离级别和MySQL的实现")]),v._v(" "),a("p",[v._v("https://juejin.im/post/5c9b1b7df265da60e21c0b57")]),v._v(" "),a("ul",[a("li",[v._v("未提交读: 一个事务修改了数据但是没有提交的时候，另一个事务读到了修改后的数据, 如果write xaction失败并且rollback, 读取的数据则为错误数据，会出现"),a("strong",[v._v("脏读")]),v._v("的问题")]),v._v(" "),a("li",[v._v("已提交读: 一个事务只能读到已提交的事务修改后的数据，并且每当事务对数据进行了修改(并提交), 该事务都能读到修改后的数据, 会出现"),a("strong",[v._v("不可重复读")]),v._v("现象")]),v._v(" "),a("li",[v._v("可重复读: 一个事务只能读到已提交的事务修改后的数据，并且如果在事务过程中重复读取时，依旧是第一次读取的结果。")]),v._v(" "),a("li",[v._v("串行化(serializable)")])]),v._v(" "),a("h3",{attrs:{id:"版本链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本链"}},[v._v("#")]),v._v(" 版本链")]),v._v(" "),a("p",[v._v("mysql每行数据存在两个字段"),a("strong",[v._v("trx_id")]),v._v("和"),a("strong",[v._v("roll_pointer")]),v._v(", 分别表示事务id和隐藏列的指针")]),v._v(" "),a("h3",{attrs:{id:"readview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#readview"}},[v._v("#")]),v._v(" ReadView")]),v._v(" "),a("p",[v._v("将mysql中所有的读写事务id全部放到"),a("strong",[v._v("m_ids")]),v._v("中，")]),v._v(" "),a("ul",[a("li",[v._v("READ COMMITED在每次读取的时候都要生成ReadView")]),v._v(" "),a("li",[v._v("REPEATABLE READ 只在第一次读取的时候生成ReadView")])]),v._v(" "),a("h2",{attrs:{id:"gc垃圾收集器整理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gc垃圾收集器整理"}},[v._v("#")]),v._v(" GC垃圾收集器整理")]),v._v(" "),a("ul",[a("li",[v._v("Serial 收集器: 是最早出现的GC, Stop the world后对新生代使用复制算法, 对老年代使用复制整理算法")]),v._v(" "),a("li",[v._v("ParNew 收集器: 是Serial的多线程并行版本")]),v._v(" "),a("li",[v._v("Parallel Scavenge: 目标是达到一个可以控制的吞吐量(Throughput), 吞吐量指用户运行代码时间与处理器运行时间的比值")]),v._v(" "),a("li",[v._v("Serial Old 收集器: Serial 收集器的老年代版本")]),v._v(" "),a("li",[v._v("Parallel Old 收集器: Parallel Scavenge 收集器的老年代版本")]),v._v(" "),a("li",[v._v("CMS (Cocurrent Low Phase Collector) 收集器: 标记步骤: 初始标记、并发标记、重新标记、并发清除\n"),a("ul",[a("li",[v._v("CMS的缺点\n"),a("ul",[a("li",[v._v("CMS 收集器对处理器的资源十分敏感")]),v._v(" "),a("li",[v._v('无法处理"浮动垃圾"')]),v._v(" "),a("li",[v._v("会产生大量空间碎片, 碎片过多时候")])])])])]),v._v(" "),a("li",[v._v("Garbage First 收集器: 面向服务应用的垃圾收集器")]),v._v(" "),a("li",[v._v("Shenandoah 收集器")]),v._v(" "),a("li",[v._v("ZGC 收集器")])]),v._v(" "),a("h2",{attrs:{id:"redis-数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-数据结构"}},[v._v("#")]),v._v(" Redis 数据结构")]),v._v(" "),a("ul",[a("li",[v._v("string")]),v._v(" "),a("li",[v._v("list")]),v._v(" "),a("li",[v._v("set")]),v._v(" "),a("li",[v._v("zset")]),v._v(" "),a("li",[v._v("map")])]),v._v(" "),a("h2",{attrs:{id:"消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),a("p",[v._v("消息队列，一般我们会简称它为MQ(Message Queue) 队列是一种先进先出的数据结构。")]),v._v(" "),a("h3",{attrs:{id:"消息队列的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列的好处"}},[v._v("#")]),v._v(" 消息队列的好处")]),v._v(" "),a("ul",[a("li",[v._v("解耦")]),v._v(" "),a("li",[v._v("一部")]),v._v(" "),a("li",[v._v("削峰/限流")])]),v._v(" "),a("h3",{attrs:{id:"消息队列要考虑什么问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列要考虑什么问题"}},[v._v("#")]),v._v(" 消息队列要考虑什么问题")]),v._v(" "),a("ul",[a("li",[v._v("高可用")]),v._v(" "),a("li",[v._v("数据丢失问题")]),v._v(" "),a("li",[v._v("消费者如何得到消息队列的数据")])]),v._v(" "),a("h2",{attrs:{id:"数据库的三大范式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库的三大范式"}},[v._v("#")]),v._v(" 数据库的三大范式")]),v._v(" "),a("ul",[a("li",[v._v("第一范式，是针对于数据表的列的规范，即数据表的每一列都是不可分割的原子数据项，而不能是数组，集合，记录等非原子数据项，说白了就是，不能把好几列的数据合在一起，且每一列的数据都是不可分割的")]),v._v(" "),a("li",[v._v("第二范式，基于第一范式，非码属性必须完全依赖码，即非主键数据必须依赖主键数据, 需要存在一行完全不同的数据。足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情")]),v._v(" "),a("li",[v._v("第三范式，其实是第二范式的子集，也是基于第一范式，任何非码属性不依赖其他非码属性。任何一个表格中不能存在传递依赖，如果存在则分开建立表格。不能间接依赖主键")])]),v._v(" "),a("h2",{attrs:{id:"redis和mysql数据怎么保持数据一致的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis和mysql数据怎么保持数据一致的？"}},[v._v("#")]),v._v(" Redis和mysql数据怎么保持数据一致的？")]),v._v(" "),a("p",[v._v("https://juejin.im/post/5c96fb795188252d5f0fdff2")]),v._v(" "),a("p",[v._v("方案一具体流程")]),v._v(" "),a("p",[v._v("（1）更新数据库数据；")]),v._v(" "),a("p",[v._v("（2）缓存因为种种问题删除失败；")]),v._v(" "),a("p",[v._v("（3）将需要删除的key发送至消息队列；")]),v._v(" "),a("p",[v._v("（4）自己消费消息，获得需要删除的key；")]),v._v(" "),a("p",[v._v("（5）继续重试删除操作，直到成功。")]),v._v(" "),a("p",[v._v("然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。")]),v._v(" "),a("p",[v._v("2、方案二具体流程")]),v._v(" "),a("p",[v._v("（1）更新数据库数据；")]),v._v(" "),a("p",[v._v("(2) 数据库会将操作信息写入binlog日志当中；")]),v._v(" "),a("p",[v._v("（3）订阅程序提取出所需要的数据以及key；")]),v._v(" "),a("p",[v._v("（4）另起一段非业务代码，获得该信息；")]),v._v(" "),a("p",[v._v("（5）尝试删除缓存操作，发现删除失败；")]),v._v(" "),a("p",[v._v("（6）将这些信息发送至消息队列；")]),v._v(" "),a("p",[v._v("（7）重新从消息队列中获得该数据，重试操作。")]),v._v(" "),a("h2",{attrs:{id:"oauth2-0协议入门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oauth2-0协议入门"}},[v._v("#")]),v._v(" OAuth2.0协议入门")]),v._v(" "),a("p",[v._v("https://juejin.im/post/5b8659b8e51d4538a67aa484")]),v._v(" "),a("p",[v._v("OAuth协议，是一种授权协议，不涉及具体的代码，只是表示一种约定的流程和规范。OAuth协议一般用于用户决定是否把自己在某个服务商上面的资源（比如：用户基本资料、照片、视频等）授权给第三方应用访问")]),v._v(" "),a("h2",{attrs:{id:"redis-大-key-优化方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-大-key-优化方案"}},[v._v("#")]),v._v(" Redis 大 key 优化方案")]),v._v(" "),a("p",[v._v("https://my.oschina.net/u/1000241/blog/3020957")]),v._v(" "),a("h3",{attrs:{id:"分拆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分拆"}},[v._v("#")]),v._v(" 分拆")]),v._v(" "),a("p",[a("strong",[v._v("每次都是整存整取")])]),v._v(" "),a("p",[v._v("这种操作一般都是每次整存整取，这种情况可以尝试将对象拆分成多个key-value，使用multiGet获取值，这样分拆意义在于分拆操作的压力，将操作压力平摊到多个redis实例，降低对于单个redis的io压力。")]),v._v(" "),a("p",[a("strong",[v._v("每次只存取部分数据")])]),v._v(" "),a("p",[v._v("同样可以拆成几个key-value，也可以将这些存储在一个hash中，每个field代表具体属性，使用hget，hmget来获取部分value，使用hset，hmset来更新部分属性。")]),v._v(" "),a("p",[a("strong",[v._v("一个集群存储了上亿的key")])]),v._v(" "),a("p",[v._v("组合那些key本身强相关性的，比如key代表一个对象，m每个key是对象的一个属性，按照这种方式设置一个新的key-hash的结构，原先的key作为这个新hash field。")]),v._v(" "),a("h2",{attrs:{id:"redis主从复制机制详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis主从复制机制详解"}},[v._v("#")]),v._v(" Redis主从复制机制详解")]),v._v(" "),a("p",[v._v("https://juejin.im/post/5d14bb8ff265da1b602915c5#heading-3")])])}),[],!1,null,null,null);_.default=s.exports}}]);