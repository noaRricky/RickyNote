<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java内存模型(一) - 一个码农的期望 | Ricky的笔记本</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="用于记录平时看的博客，养成记录的习惯">
    <link rel="preload" href="/rickynote/assets/css/0.styles.1839c5aa.css" as="style"><link rel="preload" href="/rickynote/assets/js/app.08db7897.js" as="script"><link rel="preload" href="/rickynote/assets/js/2.f8fcb9e9.js" as="script"><link rel="preload" href="/rickynote/assets/js/6.f80e8d82.js" as="script"><link rel="prefetch" href="/rickynote/assets/js/10.fed7c7a5.js"><link rel="prefetch" href="/rickynote/assets/js/11.991c36b6.js"><link rel="prefetch" href="/rickynote/assets/js/12.f99e0fb3.js"><link rel="prefetch" href="/rickynote/assets/js/13.4a75c857.js"><link rel="prefetch" href="/rickynote/assets/js/14.921f647b.js"><link rel="prefetch" href="/rickynote/assets/js/15.1de53959.js"><link rel="prefetch" href="/rickynote/assets/js/16.600aa420.js"><link rel="prefetch" href="/rickynote/assets/js/17.15677109.js"><link rel="prefetch" href="/rickynote/assets/js/18.2b9af055.js"><link rel="prefetch" href="/rickynote/assets/js/3.89957838.js"><link rel="prefetch" href="/rickynote/assets/js/4.f348005f.js"><link rel="prefetch" href="/rickynote/assets/js/5.3ed85c15.js"><link rel="prefetch" href="/rickynote/assets/js/7.ac3d2563.js"><link rel="prefetch" href="/rickynote/assets/js/8.484496ac.js"><link rel="prefetch" href="/rickynote/assets/js/9.144245ca.js">
    <link rel="stylesheet" href="/rickynote/assets/css/0.styles.1839c5aa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rickynote/" class="home-link router-link-active"><!----> <span class="site-name">Ricky的笔记本</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java内存模型-一-一个码农的期望"><a href="#java内存模型-一-一个码农的期望" class="header-anchor">#</a> Java内存模型(一) - 一个码农的期望</h1> <p>最近发现自己在产品思维上有所欠缺，并且刚刚读完《java并发编程艺术这本书》，于是决定从程序员的需求角度大概写写自己对JMM的理解，希望对大家有所帮助。</p> <h2 id="背景知识"><a href="#背景知识" class="header-anchor">#</a> 背景知识</h2> <p>了解一个解决方案首先得明白它处理的问题，通过背景知识，我们可以更好的理解它产生的原因，以及其中所包含的思想</p> <p>在单个处理器的处理速度的提升已经不在明显的时候，人们便尝试使用多种方法来提高计算机的运算效率，其中包括</p> <ul><li>引入多级缓存机制，同过减少了读取运算数据、存储运算结果等I/O操作的次数，让计算机运算快速执行，减少了处理器等待时间</li> <li>使用多核处理器，三个臭皮匠顶过顶过一个诸葛亮</li> <li>代码乱序优化，重新调整顺序的代码可以使用硬件底层的批处理等技术，加快运算效率</li></ul> <p>但同时一个全新概念的引入，往往会伴随着诸多问题等待着这些伟大的先驱者去解决。</p> <h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="header-anchor">#</a> 缓存一致性问题</h3> <p><img src="/rickynote/assets/img/JMM.16ff4fe1.png" alt="缓存一致性"></p> <p>当多个处理器要使用和修改主内存中同一块区域时，可能会导致不同处理器中的数据不一样，如何将不同CPU寄存器、高速缓存中的数据进行同步，保证数据的一致性，运算的正确性的同时保证处理器的效率是设计着需要考虑的问题。在硬件上，各个处理器都遵循了各自的一致性协议，来解决这些问题</p> <h3 id="指令重排序问题"><a href="#指令重排序问题" class="header-anchor">#</a> 指令重排序问题</h3> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># CPU1            CPU1</span>
a <span class="token operator">=</span> <span class="token number">2</span>             b <span class="token operator">=</span> <span class="token number">100</span>
b <span class="token operator">=</span> <span class="token number">100</span>           a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>      <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>
</code></pre></div><p>重排序能够有效的提高处理器的运算效率，但是重排序有时候会让结果发生错误，尤其是在多核环境下，会发生很多奇妙的问题，猜猜下面两个CPU输出的结果</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># CPU1                      CPU2</span>
a <span class="token operator">=</span> <span class="token number">10</span>                      b <span class="token operator">=</span> <span class="token number">20</span>
b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">100</span>                 a <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">100</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;b = </span><span class="token interpolation"><span class="token punctuation">{</span>b<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>           <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;a = </span><span class="token interpolation"><span class="token punctuation">{</span>a<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
</code></pre></div><p>如果已多次运行以上程序会发现，在终端中竟然出现了 a = 100, b = 100的结果, 原因是底层处理器”自以为是“的重排序使得我们运行的程序变成如下</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># CPU1                      CPU2</span>
a <span class="token operator">=</span> <span class="token number">10</span>                      b <span class="token operator">=</span> <span class="token number">20</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;b = </span><span class="token interpolation"><span class="token punctuation">{</span>b<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>           <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;a = </span><span class="token interpolation"><span class="token punctuation">{</span>a<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">100</span>                 a <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">100</span>
</code></pre></div><h3 id="各种硬件的区别"><a href="#各种硬件的区别" class="header-anchor">#</a> 各种硬件的区别</h3> <p>为解决多核处理器所带来的问题，不同的设计着提供了不同的方案，但对于程序员，了解这些策略并编写正确的程序具有很大的难度</p> <h2 id="程序员对jmm的期望"><a href="#程序员对jmm的期望" class="header-anchor">#</a> 程序员对JMM的期望</h2> <p>在生活中我们常常做不了甲方，但对于JAVA的设计者们来说，我们就是甲方，而且我们的要求不多，也并不过分</p> <h3 id="顺序一致性"><a href="#顺序一致性" class="header-anchor">#</a> 顺序一致性</h3> <p>当我们程序员写出了正确的代码的前提下，希望程序按照我们所设想的代码顺序执行，并输出正确的结果</p> <p>所以在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性作为参考，接下我们具体的谈谈顺序一致性的具体要求</p> <h4 id="数据读写与顺序一致性"><a href="#数据读写与顺序一致性" class="header-anchor">#</a> 数据读写与顺序一致性</h4> <p>当我们处理多线程问题的时候，常常会遇到如下数据竞争的问题：</p> <ul><li>线程1: 读取内存区域的x变量</li> <li>线程2: 更新内存预取的x变量</li> <li>以上两个操作如何同步？</li></ul> <p>作为程序员我们期望，当我们约定了线程1的操作先于线程2执行(反之亦然)，此时这个程序便成为了一个没有数据竞争的程序，同时我们也可以称之为正确同步的程序，该程序的执行将具有<strong>顺序一致性</strong></p> <h4 id="线程与顺序一致性"><a href="#线程与顺序一致性" class="header-anchor">#</a> 线程与顺序一致性</h4> <p>当我们运行了多个线程的时候，顺序一致性向我们保证了：</p> <ul><li>一个线程的所有操作必须按照程序的顺序来执行(无指令重排序)，所有操作只能看到一个单一的操作执行顺序(将并行转化为串行)</li> <li>每个操作必须是<strong>原子执行</strong>且立刻对所有线程可见。(注：原子执行是指这种操作一旦开始，就一直运行到结束，中间不会有任何线程切换)</li></ul> <p><img src="/rickynote/assets/img/atomicOpt.a2df3c87.png" alt="原子执行"></p> <h4 id="同步块和顺序一致性"><a href="#同步块和顺序一致性" class="header-anchor">#</a> 同步块和顺序一致性</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>floag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面实例代码中，writer()和reader()方法，分别在线程1和线程二中执行，我们也期望同步块中的执行也满足线程的<strong>顺序一致性</strong>。</p> <h3 id="代码的运行效率"><a href="#代码的运行效率" class="header-anchor">#</a> 代码的运行效率</h3> <p>在满足<strong>顺序一致性</strong>的条件下，我们希望代码的执行效率越快越好</p> <h3 id="代码的可读性和易实现"><a href="#代码的可读性和易实现" class="header-anchor">#</a> 代码的可读性和易实现</h3> <p>我们希望JAVA的设计者们能够提供安全且易实现的机制，满足顺序一致性以及执行效率，并且让我们的写出来的代码具有良好的可读性。</p> <h2 id="jmm的诞生"><a href="#jmm的诞生" class="header-anchor">#</a> JMM的诞生</h2> <h3 id="效率与一致性的博弈"><a href="#效率与一致性的博弈" class="header-anchor">#</a> 效率与一致性的博弈</h3> <p>从上文我们可以看到，顺序一致性与执行效率是相互矛盾的，所以JAVA的设计者们做了如下决定</p> <blockquote><p>在满足执行结果与程序员期望结果的前提下，尽可能的减少顺序一直性对内存模型的束缚</p></blockquote> <p>为此，提出了happens-before原则来描述这种设计理念，本文不会针对这个概念做深入的解释，但我们可以这么理解，设计者们为程序员创造了一个程序是按照顺序一致性执行的桃花源，它不会违背程序员所期望的结果，但实际过程却有所不同。</p> <h3 id="语言设计"><a href="#语言设计" class="header-anchor">#</a> 语言设计</h3> <p>java设计者们为达到可读性和易实现性，提供了一下关键字和方法</p> <ul><li>synchronized 关键字</li> <li>volatile 关键字</li> <li>final 关键字</li> <li>锁
<ul><li>concurrent包</li></ul></li></ul> <p>JMM就是由这些小部件组成</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本文主要介绍了JMM诞生的背景知识，主要介绍了硬件方面的内容，并从程序员的角度分析，JMM应该满足哪些条件，以及它的设计的总体思想</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li>《Java并发编程的艺术》</li> <li><a href="https://juejin.im/post/5bf2977751882505d840321d" target="_blank" rel="noopener noreferrer">理解java内存模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527" target="_blank" rel="noopener noreferrer">Redis深度历险:核心原理与应用实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/rickynote/assets/js/app.08db7897.js" defer></script><script src="/rickynote/assets/js/2.f8fcb9e9.js" defer></script><script src="/rickynote/assets/js/6.f80e8d82.js" defer></script>
  </body>
</html>
