<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络面试问题 | Ricky的笔记本</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="用于记录平时看的博客，养成记录的习惯">
    <link rel="preload" href="/rickynote/assets/css/0.styles.1839c5aa.css" as="style"><link rel="preload" href="/rickynote/assets/js/app.08db7897.js" as="script"><link rel="preload" href="/rickynote/assets/js/2.f8fcb9e9.js" as="script"><link rel="preload" href="/rickynote/assets/js/17.15677109.js" as="script"><link rel="prefetch" href="/rickynote/assets/js/10.fed7c7a5.js"><link rel="prefetch" href="/rickynote/assets/js/11.991c36b6.js"><link rel="prefetch" href="/rickynote/assets/js/12.f99e0fb3.js"><link rel="prefetch" href="/rickynote/assets/js/13.4a75c857.js"><link rel="prefetch" href="/rickynote/assets/js/14.921f647b.js"><link rel="prefetch" href="/rickynote/assets/js/15.1de53959.js"><link rel="prefetch" href="/rickynote/assets/js/16.600aa420.js"><link rel="prefetch" href="/rickynote/assets/js/18.2b9af055.js"><link rel="prefetch" href="/rickynote/assets/js/3.89957838.js"><link rel="prefetch" href="/rickynote/assets/js/4.f348005f.js"><link rel="prefetch" href="/rickynote/assets/js/5.3ed85c15.js"><link rel="prefetch" href="/rickynote/assets/js/6.f80e8d82.js"><link rel="prefetch" href="/rickynote/assets/js/7.ac3d2563.js"><link rel="prefetch" href="/rickynote/assets/js/8.484496ac.js"><link rel="prefetch" href="/rickynote/assets/js/9.144245ca.js">
    <link rel="stylesheet" href="/rickynote/assets/css/0.styles.1839c5aa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rickynote/" class="home-link router-link-active"><!----> <span class="site-name">Ricky的笔记本</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="计算机网络面试问题"><a href="#计算机网络面试问题" class="header-anchor">#</a> 计算机网络面试问题</h1> <h2 id="osi-应用失败的原因"><a href="#osi-应用失败的原因" class="header-anchor">#</a> OSI 应用失败的原因</h2> <ul><li>OSI 的专家缺乏实际经验，他们在王城OSI标准时缺乏商业驱动力</li> <li>OSI 协议实行起来过分复杂，而却运行效率很低</li> <li>OSI 制定标准的周期太长，因而是的按 OSI 标注生产的设备无法及时进入市场 (当OSI设计出来的时候，基于TCP/IP的互联网已经抢先在全球范围实行)</li> <li>OSI 层次划分不太合理，有些功能多个层次重复出现</li></ul> <h2 id="osi-的体系结构"><a href="#osi-的体系结构" class="header-anchor">#</a> OSI 的体系结构</h2> <ul><li>应用层</li> <li>表示层</li> <li>会话层</li> <li>运输层</li> <li>网络层</li> <li>数据链路层</li> <li>物理层</li></ul> <h2 id="五层协议的体系结果"><a href="#五层协议的体系结果" class="header-anchor">#</a> 五层协议的体系结果</h2> <ul><li>应用层: 负责在不同<strong>应用</strong>之间传递和解析数据</li> <li>运输层: 负责在不同<strong>进程</strong>之间传输和解析数据</li> <li>网络层: 负责在不同<strong>主机</strong>之间传输和解析数据</li> <li>数据链路层: 主机之间传递数据，总是在<strong>一段一段的链路</strong>上发送的</li> <li>物理层: 发送数据的单位是比特，相对于数据链路层屏蔽掉不同设备之间传输数据的不同</li></ul> <h2 id="udp的主要特点"><a href="#udp的主要特点" class="header-anchor">#</a> UDP的主要特点:</h2> <ul><li>UDP是无连接的；</li> <li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多- 参数）；</li> <li>UDP是面向报文的；</li> <li>UDP没有拥塞控制，因此网络出现拥塞<strong>不会使源主机的发送速率降低</strong>（对实时应用很有用，如IP电话，实时视频会议等）；</li> <li>UDP支持一对一、一对多、多对一和多对多的交互通信；
UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li> <li>小结: 无连接, 传输不可靠, 数据报文段, 传输速率快, 所需资源少, 应用在通信速度快的场景中, 头部8个字节</li></ul> <h2 id="tcp的主要特点"><a href="#tcp的主要特点" class="header-anchor">#</a> TCP的主要特点:</h2> <ul><li>TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li> <li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li> <li>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li> <li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li> <li>面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li> <li>小结: 面向连接, 可靠传输(相对), 数据流, 传输速率慢, 所需资源多, 应用在保证数据的可靠性, 头部20-60个字节</li> <li><strong>问题TCP、UDP协议的区别</strong></li></ul> <h2 id="tcp-三次握手和四次挥手"><a href="#tcp-三次握手和四次挥手" class="header-anchor">#</a> TCP 三次握手和四次挥手</h2> <p>详细阅读文章: https://blog.csdn.net/qzcsu/article/details/72861891</p> <ul><li>发送端: SYN -&gt; 接收端</li> <li>发送端: &lt;- SYN/ACK 接收端，注: 当发送段收到 SYN/ACK 的数据包是证明发送端发送功能和接收端接受功能没有问题</li> <li>发送端: ACK -&gt; 接收端，注: 当接收端接收到 ACK 报文后，证明接收端能正确发送报文，发送端接收报文没有问题</li></ul> <h3 id="在三次握手中，为什么tcp客户段还要再发送一次"><a href="#在三次握手中，为什么tcp客户段还要再发送一次" class="header-anchor">#</a> 在三次握手中，为什么TCP客户段还要再发送一次</h3> <ul><li>如果客户端不想服务器发送报文服务器无法确认客户端发送功能是否正确，服务器的发送功能是否正确</li> <li>在两次握手的前提下，如果第一次SYN报文因为网络延迟，在TCP关闭链接之后到达服务器，服务器又会发送 SYN/ACK 报文建立TCP链接此时，然而这个链接是失效的，所以增加第三次握手时服务器会判断该该 SYN/ACK 请求是否有效，避免产生无效的 TCP 链接</li></ul> <h3 id="在四次挥手过程中，为什么客户端还要等待-2msl-的时间"><a href="#在四次挥手过程中，为什么客户端还要等待-2msl-的时间" class="header-anchor">#</a> 在四次挥手过程中，为什么客户端还要等待 2MSL 的时间</h3> <ul><li>站在服务器的角度来看，当它发送的 FIN/ACK 报文没有收到服务器的相应，会重新发送报文，该2MSL的时间就是用于处理延迟情况的</li> <li>防止类似于“三次握手”过程中提到的“失效报文导致的错误链接结果”，在该 2MSL 的时间中客户端可以删除所有本链接持续时间内所有的报文从网络中消失</li></ul> <h2 id="打开一个网页，整个过程会使用哪些协议"><a href="#打开一个网页，整个过程会使用哪些协议" class="header-anchor">#</a> 打开一个网页，整个过程会使用哪些协议</h2> <p>详细阅读文章: https://segmentfault.com/a/1190000006879700</p> <ul><li>过程中依次遇到的协议
<ul><li>DNS
<ul><li>DNS 解析过程: 本地DNS缓存 - 路由器缓存 - 根域名服务器 - com 域名顶级服务器 - baidu 顶级域名服务器 - www 顶级域名服务器</li> <li>DNS 优化
<ul><li>DNS 缓存，浏览器缓存，系统缓存 /etc/hosts</li> <li>DNS 分布式优化: DNS 服务器会根据请求的位置，返回离客户端最近的服务器 IP 地址</li></ul></li></ul></li> <li>HTTP HTTPS: HTTPS 使用 SSL or TLS 对 HTTP 请求进行加密</li> <li>TCP</li> <li>IP</li> <li>TCP</li> <li>HTTP</li></ul></li></ul> <h2 id="http长连接、短连接"><a href="#http长连接、短连接" class="header-anchor">#</a> HTTP长连接、短连接</h2> <p>在 HTTP/1.1 协议中支持: Connection: keep-alive，实际上是 TCP 协议的长连接和短连接</p> <p><a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener noreferrer">HTTP长连接、短连接究竟是什么<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="服务器如何探测客户端的状态"><a href="#服务器如何探测客户端的状态" class="header-anchor">#</a> 服务器如何探测客户端的状态</h3> <ul><li>服务器发送一个探测报文，如果客户端相应保持连接</li> <li>如果客户端死机、重新启动或者网络不通畅，客服端无法回复，则服务器会连续发送十次探测报文，如果没有一个相应则关闭连接</li> <li>客户端宕机重启后，收到探测报文，会返回一个复位响应，之后服务器关闭链接</li></ul> <h3 id="tcp-协议如何保证可靠传输"><a href="#tcp-协议如何保证可靠传输" class="header-anchor">#</a> TCP 协议如何保证可靠传输</h3> <ul><li>应用数据被分割成TCP合适的数据块</li> <li>TCP将数据块进行编号，接收端对接收到的数据进行排序，发送给应用层</li> <li>TCP 接收端会丢失重复的数据</li> <li>校验和</li> <li>阻塞控制</li> <li>流量控制</li> <li>ARQ协议: 发送端会维护一个滑动窗口进行发送，发送窗口的信息后，就停止发送等待接收端的确认信息</li> <li>超时重传</li></ul> <h3 id="arq协议"><a href="#arq协议" class="header-anchor">#</a> ARQ协议</h3> <p>自动重传协议 (Automatic Repeat-reQuest, ARQ) 使用确认和超时两个机制使得在不可靠传输的基础上建立可靠的传输，包括 <strong>停止等待ARQ</strong> 和 <strong>连续ARQ协议</strong></p> <h4 id="停止等待"><a href="#停止等待" class="header-anchor">#</a> 停止等待</h4> <p>耗时，实现简单</p> <h4 id="连续arq协议"><a href="#连续arq协议" class="header-anchor">#</a> 连续ARQ协议</h4> <ul><li>发送端维护一个发送窗口</li> <li>当发生超时的问题时候，只发送接收号之后的报文</li></ul> <h3 id="阻塞控制"><a href="#阻塞控制" class="header-anchor">#</a> 阻塞控制</h3> <ul><li>慢开始</li> <li>阻塞避免</li> <li>快重传</li> <li>快恢复</li></ul> <h3 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="header-anchor">#</a> Cookie 和 Session 的区别</h3> <ul><li>Cookie 用来保存用户的<strong>信息</strong> Session 用来保存用户的<strong>状态</strong></li></ul> <h3 id="http1-0-和-http1-1-的区别"><a href="#http1-0-和-http1-1-的区别" class="header-anchor">#</a> HTTP1.0 和 HTTP1.1 的区别</h3> <ul><li>长连接</li> <li>错误状态吗</li> <li>缓存处理</li> <li>带宽优化和网络连接的使用</li></ul> <h3 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="header-anchor">#</a> HTTP 和 HTTPS 的区别</h3> <ul><li>HTTP端口在80, HTTPS的端口在443, HTTPS 是运行在 SSL/TLS 之上的协议</li> <li>HTTPS 对 HTTP 的报文进行非对称加密 并发送给TCP
<ul><li>对称加密: 加密解密使用同一个密码</li> <li>非对称加密: 存在公钥和私钥，公钥加密私钥解密，私钥加密公钥解密</li></ul></li></ul> <h2 id="rerference"><a href="#rerference" class="header-anchor">#</a> Rerference</h2> <ul><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener noreferrer">图解SSL/TLS协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/rickynote/assets/js/app.08db7897.js" defer></script><script src="/rickynote/assets/js/2.f8fcb9e9.js" defer></script><script src="/rickynote/assets/js/17.15677109.js" defer></script>
  </body>
</html>
